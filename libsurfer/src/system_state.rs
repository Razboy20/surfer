use std::{
    cell::RefCell,
    collections::VecDeque,
    sync::{atomic::AtomicBool, Arc},
    thread::JoinHandle,
};

use egui::{Pos2, Rect};

use crate::{
    benchmark::Timing,
    command_prompt,
    displayed_item::DisplayedItemRef,
    message::Message,
    translation::{all_translators, TranslatorList},
    wave_source::LoadProgress,
    CachedDrawData, CanvasState, Channels,
};

pub struct SystemState {
    /// Which translator to use for each variable
    pub(crate) translators: TranslatorList,
    /// Channels for messages generated by other threads
    pub channels: Channels,

    /// Tracks progress of file/variable loading operations.
    pub(crate) progress_tracker: Option<LoadProgress>,

    /// Buffer for the command input
    pub(crate) command_prompt: command_prompt::CommandPrompt,

    /// The context to egui, we need this to change the visual settings when the config is reloaded
    pub(crate) context: Option<Arc<egui::Context>>,

    /// List of batch commands which will executed as soon as possible
    pub(crate) batch_commands: VecDeque<Message>,
    pub(crate) batch_commands_completed: bool,

    /// The WCP server
    pub(crate) wcp_server_thread: Option<JoinHandle<()>>,
    pub(crate) wcp_server_address: Option<String>,
    pub(crate) wcp_stop_signal: Arc<AtomicBool>,
    pub(crate) wcp_server_load_outstanding: bool,

    /// The draw commands for every variable currently selected
    // For performance reasons, these need caching so we have them in a RefCell for interior
    // mutability
    pub(crate) draw_data: RefCell<Vec<Option<CachedDrawData>>>,

    pub(crate) gesture_start_location: Option<Pos2>,

    // Egui requires a place to store text field content between frames
    pub(crate) url: RefCell<String>,
    pub(crate) command_prompt_text: RefCell<String>,
    pub(crate) last_canvas_rect: RefCell<Option<Rect>>,
    pub(crate) variable_name_filter: RefCell<String>,
    pub(crate) item_renaming_string: RefCell<String>,

    /// These items should be expanded into subfields in the next frame. Cleared after each
    /// frame
    pub(crate) items_to_expand: RefCell<Vec<(DisplayedItemRef, usize)>>,
    /// Character to add to the command prompt if it is visible. This is only needed for
    /// presentations at them moment.
    pub(crate) char_to_add_to_prompt: RefCell<Option<char>>,

    // Benchmarking stuff
    /// Invalidate draw commands every frame to make performance comparison easier
    pub(crate) continuous_redraw: bool,
    #[cfg(feature = "performance_plot")]
    pub(crate) rendering_cpu_times: VecDeque<f32>,
    #[cfg(feature = "performance_plot")]
    pub(crate) timing: RefCell<Timing>,

    // Undo and Redo stacks
    pub(crate) undo_stack: Vec<CanvasState>,
    pub(crate) redo_stack: Vec<CanvasState>,
}

impl Default for SystemState {
    fn default() -> Self {
        Self::new()
    }
}

impl SystemState {
    pub fn new() -> Self {
        let channels = Channels::new();

        // Basic translators that we can load quickly
        let translators = all_translators();

        Self {
            translators,
            channels,
            progress_tracker: None,
            command_prompt: command_prompt::CommandPrompt {
                visible: false,
                suggestions: vec![],
                selected: 0,
                new_selection: None,
                new_cursor_pos: None,
                previous_commands: vec![],
            },
            context: None,
            wcp_server_thread: None,
            wcp_server_address: None,
            wcp_stop_signal: Arc::new(AtomicBool::new(false)),
            wcp_server_load_outstanding: false,
            gesture_start_location: None,
            batch_commands: VecDeque::new(),
            batch_commands_completed: false,
            url: RefCell::new(String::new()),
            command_prompt_text: RefCell::new(String::new()),
            draw_data: RefCell::new(vec![None]),
            last_canvas_rect: RefCell::new(None),
            variable_name_filter: RefCell::new(String::new()),
            item_renaming_string: RefCell::new(String::new()),

            items_to_expand: RefCell::new(vec![]),
            char_to_add_to_prompt: RefCell::new(None),

            continuous_redraw: false,
            #[cfg(feature = "performance_plot")]
            rendering_cpu_times: VecDeque::new(),
            #[cfg(feature = "performance_plot")]
            timing: RefCell::new(Timing::new()),
            undo_stack: vec![],
            redo_stack: vec![],
        }
    }
}
